# leetcode84 柱状图中最大的矩形
给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。

求在该柱状图中，能够勾勒出来的矩形的最大面积。

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/histogram.png)

以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 [2,1,5,6,2,3]。

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/histogram_area.png)

图中阴影部分为所能勾勒出的最大矩形面积，其面积为 10 个单位。

**示例：**
```
输入: [2,1,5,6,2,3]
输出: 10
```

# 题解
## 暴力+简单优化
一开始用的是暴力枚举+rightActive优化。结果通过了，但执行用时1656ms，显然还有优化的空间。

暴力枚举就是固定高度，找最大宽度。高度就是当前数组元素的值，而宽度就是分别左右遍历大于当前元素的值。这里的rightActive优化是指，如果一个元素的下一个数大于自己，那么当遍历到下一个数时，它左边的数一定是小于自己的，因此左边就不用再遍历了。通过rightActive来记录这个状态。当rightActive为false的时候才遍历左边。

## 单调栈
在用暴力解法进行遍历的过程中，可以发现，在遍历的时候，如果一个矩形bar的高度大于与他相邻的下一个矩形nextBar的高度，那么以矩形bar的高为高的最大矩形就已经可以确定了。也就是说，一定存在一种方案，只需要遍历一次数组，就能将结果算出来。

### 流程分析
1. 创建一个单调递增栈
2. 遍历heights数组，如果当前bar比栈顶的bar高，直接入栈
3. 否则，栈顶元素出栈，记录栈顶元素的索引topIndex
4. 计算以`heights[topIndex]`为高的长方形的面积
    它的宽度 = 当前 bar 的索引 `index` - 新的栈顶索引`stack[stack.length-1]` - 1
    更新最大面积
5. 当前 bar 继续和新的栈顶比较，重复上面过程
6. 直到当前 bar 不再比栈顶的 bar 矮，入栈
ps: 栈中始终维持着 bar 高的单调递增性

### 边界情况的处理
在数组的开始和结尾添加数字0，表示高度为0的矩形。这样是每一个矩形都有栈顶可以比较。
