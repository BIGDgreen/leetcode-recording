# 与链表相关的算法写代码提示

# 1. 设置哑节点作为开头
在头节点之前设置一个哑节点可以避免一些情况下头节点的讨论，比如删除和添加。因为此时每个链表节点的上一个节点都存在。

**设置方法：**
```js
const dummyHead = new ListNode(0)
dummyHead.next = head
```

# 2. 可以同时使用多个指针
例如双指针：
## 双指针
在本系列中，`141 环形链表`、`142 环形链表2`、`160 相交链表`和`203 删除链表的倒数第N个节点`这四个题中用到了双指针。

两个指针的行走速度要么都为1；要么一个1，一个2。

为什么是2而不是其他的数呢？因为如果是其他的数的话，指针到底了，我们无法确认实际的尾部。就比如速度是3，到底之后，无法确定是多走了一步还是两步。

## 双指针的用途：

1. 利用两个指针的相交，获得**相交点**。而我们可以创建各种条件让这个相交点变得有意义。
2. 利用两个指针之间的距离

## 使用双指针复杂度分析
**空间复杂度：**
在只使用了指针的情况下为O(1)

**时间复杂度：**
由循环的次数决定。

# 3. 双链表
双链表节点结构：
```js
class ListNode {
  constructor(val) {
    this.val = val
    this.next =  null;
    this.prev = null;
  }
}
```
多了一个指针连接上一个节点。使用双链表，对应的添加、删除操作都会做出改变。

# 4. 写代码之前用几个不同的示例来验证算法

# 5. 很多情况下需要跟踪当前节点的前一个节点
这是指单链表的情况，双链表前一个节点很容易得到。

# 6. 在调用 next 字段之前，始终检查节点是否为空

# 7. 仔细定义循环的结束条件

# 8. 与其他数据结构对比
链表的特点：
1. 无法在常量时间内访问随机数据
2. 能够在 O(1) 时间内在给定结点之后或列表开头添加一个新结点
3. 都能够在 O(1) 时间内删除**第一个结点**

但是删除给定结点(包括最后一个结点)时略有不同：

- 在单链表中，它无法获取给定结点的前一个结点，因此在删除给定结点之前我们必须花费 O(N) 时间来找出前一结点
  
- 在双链表中，这会更容易，因为我们可以使用“prev”引用字段获取前一个结点。因此我们可以在 O(1) 时间内删除给定结点

## 与其他数据结构（数组、队列、栈）的时间复杂度比较
![](https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/04/29/screen-shot-2018-04-28-at-174531.png)

## 结论

> 
> 如果你需要经常添加或删除结点，链表可能是一个不错的选择。
> 
> 如果你需要经常按索引访问元素，数组可能是比链表更好的选择。
> 