# leetcode238 除自身以外数组的乘积
给你一个长度为 n 的整数数组 nums，其中 n > 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。

**示例:**
```
输入: [1,2,3,4]
输出: [24,12,8,6]
```

**提示：**题目数据保证数组之中任意元素的全部前缀元素和后缀（甚至是整个数组）的乘积都在 32 位整数范围内。

说明: 请不要使用除法，且在 O(n) 时间复杂度内完成此题。

**进阶：**

你可以在常数空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组不被视为额外空间。）

# 题解
本题最直观的解法是先求出所有数的乘积，然后除以对应的数，得到除该数以外的其他数的乘积。该方法不适合数组中存在0的情况，且题目要求不能用除法，因此这种方法被舍弃。

## 前缀积*后缀积
现在考虑另一种解法 —— 前缀积*后缀积。

这种方法很好理解，对于一个数来说，除他之外的所有数的乘积就等于`它之前的所有数乘积 * 它之后的所有数乘积`。

按照这种思路来说，只存在一层遍历，时间复杂度为`O(n)`符合要求。但需要有三个数组分别用来保存前缀积、后缀积和结果数组，结果数组不被视为额外空间，因此额外构造了前缀积和后缀积两个数组，空间复杂度为`O(n)`。但题目要求空间复杂度为`O(1)`。因此还有优化的空间。

### 优化
由于结果数组不被视为额外空间，因此我们可以重复利用这个结果数组。在优化的算法中，不再构造前缀积和后缀积两个数组，而是将结果直接反映在结果数组，数组中对应的值进行更新即可。

### 整体思路
1. 声明结果数组`res`，声明变量`tmp`用来保存前缀积或后缀积，初始化为1，表示第一个数的前缀积为1。
2. 遍历数组`nums`，更新`res[i] = tmp`（由于tmp初始化过，因此将res的更新放在前面），依次求出当前元素的前缀积，更新`tmp *= nums[i]`。
3. 将tmp重新赋值为1，表示最后一个数的后缀积为1。
4. 反向遍历数组`nums`，更新`res[i] *= tmp`，依次求出当前元素的后缀积，更新`tmp *= nums[i]`。
5. 返回结果数组`res`。
